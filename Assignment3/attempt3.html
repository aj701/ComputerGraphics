
<!-- saved from url=(0049)http://ajlevine.com/compg/code2/index-trans1.html -->
<html hola_ext_inject="disabled"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><script src="./attempt3_files/lib1.js"></script>
<style type="text/css"></style></head><body bgcolor="black" class=" hasGoogleVoiceExt">
<center>
<canvas id="canvas1" width="600" height="600"></canvas>
</center>


<script id="my_vertex_shader" type="x-shader/x-vertex">
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id="my_fragment_shader" type="x-shader/x-fragment">
   precision mediump float;
   uniform float uTime; // my clock
   uniform vec3  uCursor; //my cursor position
   varying vec3  vPosition;
   vec4 sphere; //make spheres
   vec3 material; //my rgb material

   vec3 Lrgb; // my color of light
   vec3 Ldir; // my light direction

//noise code from class
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
float noise(vec3 P) {
   vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
   vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
   vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
   vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
   vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
   vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
   vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
   gx0 = fract(gx0); gx1 = fract(gx1);
   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
   gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
   gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
   vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
   vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
   vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
   g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
   g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
   vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
                      dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
                 vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
                      dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
   return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
}
float noise(vec2 P) { return noise(vec3(P, 0.0)); }
float fractal(vec3 P) {
   float f = 0., s = 1.;
   for (int i = 0 ; i < 9 ; i++) {
      f += noise(s * P) / s;
      s *= 2.;
      P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
   }
   return f;
}
float turbulence(vec3 P) {
   float f = 0., s = 1.;
   for (int i = 0 ; i < 9 ; i++) {
      f += abs(noise(s * P)) / s;
      s *= 2.;
      P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);
   }
   return f;
}
//end of noise from professor

   // Compute intersection of a ray with a sphere, if any.  Return t.
   // If there is no intersection, return 10000.

   float raySphere(vec3 V, vec3 W, vec4 sph) {

      //YOU NEED TO COMPUTE t, BY SETTING UP AND THEN SOLVING A QUADRATIC EQUATION.
      vec3 D = V - sph.xyz; // computing t quadratic equation
      float c = dot(D, D) - (sph.w * sph.w);
      float b = dot(W, D);
      float d = b * b - c;
      float t = -b - sqrt(d);
         return t; 
 
   }
   // Diffusely shade a sphere.
   //    point is the x,y,z position of the surface point.
   //    sphere is the x,y,z,r definition of the sphere.
   //    material is the r,g,b color of the sphere.

   vec3 shadeSphere(vec3 point, vec4 sphere, vec3 material) {
      
      // myTurb - point: larger= smaller noise and opposite
      // - uTime - speed... increase get nice water effect
      float myTurb = turbulence(cos(point/0.65) + sin(uTime) * -0.1 + noise(sin(point + uTime*0.1)));
      float myFrac = fractal(cos(point/0.65) + sin(uTime) * -0.1 + noise(sin(point + uTime*0.1)));
      vec3 ambient = material / 3.;
      vec3 diffuse = vec3(myTurb, 0.0, 0.0); // only red value affecting
      vec3 normal = (point - sphere.xyz) / sphere.w;
      vec3 color = ambient + Lrgb*diffuse*max(0.2,dot(Ldir, normal)); //new color - first number in max affecting opacity

      // YOU NEED TO COMPUTE COLOR FOR A DIFFUSELY SHADED SPHERE.
      // FOR THE AMBIENT COMPONENT OF THE DIFFUSE SHADING, YOU CAN
      // USE A SIMPLE APPROXIMATION SUCH AS: ambient = material / 5.;

      return color;
   }

   void main(void) {
      vec2 c = uCursor.xy;
      Lrgb = vec3(1.0, 0.0, 0.0); //light color - why does only red react?
      //Ldir = normalize(vec3(c.x, c.y, 1. - 2. * dot(c, c))); // light direction
      Ldir = normalize(vec3(sin(uTime), 0.001*sin(uTime), cos(uTime)));
      // float s = 0.0; //aj

      // YOU NEED TO COMPUTE V AND W TO CREATE THE RAY FOR THIS PIXEL,
      // USING vPosition.x AND vPosition.y.

      vec3 V, W;
      V = vec3(sin(uTime), cos(uTime), 1.); //aj
      //W = vec3(vPosition.x, vPosition.y, -5.); //aj
      W = normalize(vec3(vPosition.x, vPosition.y, -V.z)); // not sure?

      // YOU NEED TO SET x,y,z AND r FOR sphere.
      sphere = vec4(0., 0., -10., 6.); //aj
      // sphere1 = vec4(0.,0., -5. 3.);

      // YOU NEED TO SET r,g,b FOR material.
      //float myTurb2 = turbulence(cos(point/0.65) + sin(uTime) * -0.1 + noise(sin(point + uTime*0.1)));

      material = vec3(sin(uTime), cos(uTime), 0.4); //aj
      vec3 color = vec3(0., 0., 0.);


      float t = raySphere(V, W, sphere);
      
      if (t > 0.) {
         // material = vec3(0.75, 0.5, 1.0);
         color = shadeSphere(V + t * W, sphere, material);
      }

       //color.r = 0.2; // We added this line in class. - removing background

      color = pow(color, vec3(.45,.45,.45)); // Do Gamma correction.
      gl_FragColor = vec4(color, 1.);        // Set opacity to 1.
   }
</script>

<script>
start_gl('canvas1', document.getElementById('my_vertex_shader'  ).innerHTML,
                    document.getElementById('my_fragment_shader').innerHTML);
</script>

</body><script>function inject() {
	
	var originalOpenWndFnKey = "originalOpenFunction";

			var originalWindowOpenFn 	= window.open,
			    originalCreateElementFn = document.createElement,
			    originalCreateEventFn 	= document.createEvent,
				windowsWithNames = {};
			var timeSinceCreateAElement = 0;
			var lastCreatedAElement = null;
			var fullScreenOpenTime;
			var parentOrigin = (window.location != window.parent.location) ? document.referrer: document.location;

			window[originalOpenWndFnKey] = window.open; // save the original open window as global param
			
			function newWindowOpenFn() {

				var openWndArguments = arguments,
					useOriginalOpenWnd = true,
					generatedWindow = null;

				function blockedWndNotification(openWndArguments) {
					parent.postMessage({ type: "blockedWindow", args: JSON.stringify(openWndArguments) }, parentOrigin);
				}

				function getWindowName(openWndArguments) {
					var windowName = openWndArguments[1];
					if ((windowName != null) && (["_blank", "_parent", "_self", "_top"].indexOf(windowName) < 0)) {
						return windowName;
					}

					return null;
				}

				function copyMissingProperties(src, dest) {
					var prop;
					for(prop in src) {
						try {
							if (dest[prop] === undefined) {
								dest[prop] = src[prop];
						}
						} catch (e) {}
					}
					return dest;
				}

					// the element who registered to the event
					var capturingElement = null;
					if (window.event != null) {
						capturingElement = window.event.currentTarget;
					}

					if (capturingElement == null) {
						var caller = openWndArguments.callee;
						while ((caller.arguments != null) && (caller.arguments.callee.caller != null)) {
							caller = caller.arguments.callee.caller;
						}
						if ((caller.arguments != null) && (caller.arguments.length > 0) && (caller.arguments[0].currentTarget != null)) {
							capturingElement = caller.arguments[0].currentTarget;
						}
					}

				/////////////////////////////////////////////////////////////////////////////////
				// Blocked if a click on background element occurred (<body> or document)
				/////////////////////////////////////////////////////////////////////////////////

					if ((capturingElement != null) && (
							(capturingElement instanceof Window) ||
							(capturingElement === document) ||
							(
								(capturingElement.URL != null) && (capturingElement.body != null)
							) ||
							(
								(capturingElement.nodeName != null) && (
									(capturingElement.nodeName.toLowerCase() == "body") ||
									(capturingElement.nodeName.toLowerCase() == "#document")
								)
							)
						)) {
							window.pbreason = "Blocked a new window opened with URL: " + openWndArguments[0] + " because it was triggered by the " + capturingElement.nodeName + " element";
							// console.info(window.pbreason);
							useOriginalOpenWnd = false;
					} else {
						useOriginalOpenWnd = true;
					}
				/////////////////////////////////////////////////////////////////////////////////



				/////////////////////////////////////////////////////////////////////////////////
				// Block if a full screen was just initiated while opening this url.
				/////////////////////////////////////////////////////////////////////////////////

					// console.info("fullscreen: " + ((new Date()).getTime() - fullScreenOpenTime));
					// console.info("webkitFullscreenElement: " + document.webkitFullscreenElement);
					var fullScreenElement = document.webkitFullscreenElement || document.mozFullscreenElement || document.fullscreenElement
					if ((((new Date()).getTime() - fullScreenOpenTime) < 1000) || ((isNaN(fullScreenOpenTime) && (isDocumentInFullScreenMode())))) {

						window.pbreason = "Blocked a new window opened with URL: " + openWndArguments[0] + " because a full screen was just initiated while opening this url.";
						// console.info(window.pbreason);

						/* JRA REMOVED
						if (window[script_params.fullScreenFnKey]) {
							window.clearTimeout(window[script_params.fullScreenFnKey]);
						}
						*/

						if (document.exitFullscreen) {
							document.exitFullscreen();
						}
						else if (document.mozCancelFullScreen) {
							document.mozCancelFullScreen();
						}
						else if (document.webkitCancelFullScreen) {
							document.webkitCancelFullScreen();
						}

						useOriginalOpenWnd = false;
					}
				/////////////////////////////////////////////////////////////////////////////////


				if (useOriginalOpenWnd == true) {

					// console.info("allowing new window to be opened with URL: " + openWndArguments[0]);

					generatedWindow = originalWindowOpenFn.apply(this, openWndArguments);

					// save the window by name, for latter use.
					var windowName = getWindowName(openWndArguments);
					if (windowName != null) {
						windowsWithNames[windowName] = generatedWindow;
					}

					// 2nd line of defence: allow window to open but monitor carefully...

					/////////////////////////////////////////////////////////////////////////////////
					// Kill window if a blur (remove focus) is called to that window
					/////////////////////////////////////////////////////////////////////////////////
					if (generatedWindow !== window) {
						var openTime = (new Date()).getTime();
						var originalWndBlurFn = generatedWindow.blur;
						generatedWindow.blur = function() {
							if (((new Date()).getTime() - openTime) < 1000 /* one second */) {
								window.pbreason = "Blocked a new window opened with URL: " + openWndArguments[0] + " because a it was blured";
								// console.info(window.pbreason);
								generatedWindow.close();
								blockedWndNotification(openWndArguments);
							} else {
								// console.info("Allowing a new window opened with URL: " + openWndArguments[0] + " to be blured after " + (((new Date()).getTime() - openTime)) + " seconds");
								originalWndBlurFn();
							}
						};
					}
					/////////////////////////////////////////////////////////////////////////////////

				} else { // (useOriginalOpenWnd == false)

						var location = {
							href: openWndArguments[0]
						};
						location.replace = function(url) {
							location.href = url;
						};

						generatedWindow = {
							close:						function() {return true;},
							test:						function() {return true;},
							blur:						function() {return true;},
							focus:						function() {return true;},
							showModelessDialog:			function() {return true;},
							showModalDialog:			function() {return true;},
							prompt:						function() {return true;},
							confirm:					function() {return true;},
							alert:						function() {return true;},
							moveTo:						function() {return true;},
							moveBy:						function() {return true;},
							resizeTo:					function() {return true;},
							resizeBy:					function() {return true;},
							scrollBy:					function() {return true;},
							scrollTo:					function() {return true;},
							getSelection:				function() {return true;},
							onunload:					function() {return true;},
							print:						function() {return true;},
							open:						function() {return this;},
							opener:						window,
							closed:						false,
							innerHeight:				480,
							innerWidth:					640,
							name:						openWndArguments[1],
							location:					location,
							document:					{location: location}
						};

					copyMissingProperties(window, generatedWindow);

					generatedWindow.window = generatedWindow;

					var windowName = getWindowName(openWndArguments);
					if (windowName != null) {
						try {
							// originalWindowOpenFn("", windowName).close();
							windowsWithNames[windowName].close();
							// console.info("Closed window with the following name: " + windowName);
						} catch (err) {
							// console.info("Couldn't close window with the following name: " + windowName);
						}
					}

					setTimeout(function() {
						var url;
						if (!(generatedWindow.location instanceof Object)) {
							url = generatedWindow.location;
						} else if (!(generatedWindow.document.location instanceof Object)) {
							url = generatedWindow.document.location;
						} else if (location.href != null) {
							url = location.href;
						} else {
							url = openWndArguments[0];
						}
						openWndArguments[0] = url;
						blockedWndNotification(openWndArguments);
					}, 100);
				}

				return generatedWindow;
			}


			/////////////////////////////////////////////////////////////////////////////////
			// Replace the window open method with Poper Blocker's
			/////////////////////////////////////////////////////////////////////////////////
			window.open = function() {
				try {
					return newWindowOpenFn.apply(this, arguments);
				} catch(err) {
					return null;
				}
			};
			/////////////////////////////////////////////////////////////////////////////////



			//////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Monitor dynamic html element creation to prevent generating <a> elements with click dispatching event
			//////////////////////////////////////////////////////////////////////////////////////////////////////////
			document.createElement = function() {

					var newElement = originalCreateElementFn.apply(document, arguments);

					if (arguments[0] == "a" || arguments[0] == "A") {
						
						timeSinceCreateAElement = (new Date).getTime();

						var originalDispatchEventFn = newElement.dispatchEvent;

						newElement.dispatchEvent = function(event) {
							if (event.type != null && (("" + event.type).toLocaleLowerCase() == "click")) {
								window.pbreason = "blocked due to an explicit dispatchEvent event with type 'click' on an 'a' tag";
								// console.info(window.pbreason);
								parent.postMessage({type:"blockedWindow", args: JSON.stringify({"0": newElement.href}) }, parentOrigin);
								return true;
							}

							return originalDispatchEventFn(event);
						};

						lastCreatedAElement = newElement;

					}

					return newElement;
			};
			/////////////////////////////////////////////////////////////////////////////////




			/////////////////////////////////////////////////////////////////////////////////
			// Block artificial mouse click on frashly created <a> elements
			/////////////////////////////////////////////////////////////////////////////////
			document.createEvent = function() {
				try {
					if ((arguments[0].toLowerCase().indexOf("mouse") >= 0) && ((new Date).getTime() - timeSinceCreateAElement) <= 50) {
						window.pbreason = "Blocked because 'a' element was recently created and " + arguments[0] + " event was created shortly after";
						// console.info(window.pbreason);
						arguments[0] = lastCreatedAElement.href;
						parent.postMessage({ type: "blockedWindow", args: JSON.stringify({"0": lastCreatedAElement.href}) }, parentOrigin);
						return null;
					}
					return originalCreateEventFn.apply(document, arguments);
				} catch(err) {}
			};
			/////////////////////////////////////////////////////////////////////////////////





			/////////////////////////////////////////////////////////////////////////////////
			// Monitor full screen requests
			/////////////////////////////////////////////////////////////////////////////////
			function onFullScreen(isInFullScreenMode) {
					if (isInFullScreenMode) {
						fullScreenOpenTime = (new Date()).getTime();
						// console.info("fullScreenOpenTime = " + fullScreenOpenTime);
					} else {
						fullScreenOpenTime = NaN;
					}
			};
			/////////////////////////////////////////////////////////////////////////////////

			function isDocumentInFullScreenMode() {
				// Note that the browser fullscreen (triggered by short keys) might
				// be considered different from content fullscreen when expecting a boolean
				return ((document.fullScreenElement && document.fullScreenElement !== null) ||    // alternative standard methods
					((document.mozFullscreenElement != null) || (document.webkitFullscreenElement != null)));                   // current working methods
			}

			document.addEventListener("fullscreenchange", function () {
				onFullScreen(document.fullscreen);
			}, false);

			document.addEventListener("mozfullscreenchange", function () {
				onFullScreen(document.mozFullScreen);
			}, false);

			document.addEventListener("webkitfullscreenchange", function () {
				onFullScreen(document.webkitIsFullScreen);
			}, false);

		} inject()</script></html>